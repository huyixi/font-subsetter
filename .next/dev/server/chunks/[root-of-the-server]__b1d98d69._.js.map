{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/huyixi/i/font-subsetter/lib/outputFormats.ts"],"sourcesContent":["export const OUTPUT_FORMATS = [\n  { id: 'ttf', label: 'TTF' },\n  { id: 'woff2', label: 'WOFF2' },\n  { id: 'woff', label: 'WOFF' },\n] as const\n\nexport type OutputFormat = (typeof OUTPUT_FORMATS)[number]['id']\n\nexport const OUTPUT_MIME_TYPES: Record<OutputFormat, string> = {\n  ttf: 'font/ttf',\n  woff2: 'font/woff2',\n  woff: 'font/woff',\n}\n\nexport const FORMAT_TO_TARGET: Record<OutputFormat, 'sfnt' | 'woff2' | 'woff'> = {\n  ttf: 'sfnt',\n  woff2: 'woff2',\n  woff: 'woff',\n}\n\nexport const DEFAULT_OUTPUT_FORMAT: OutputFormat = 'ttf'\n\nexport function isOutputFormat(value: string): value is OutputFormat {\n  return OUTPUT_FORMATS.some((format) => format.id === value)\n}\n\nconst EXTENSION_REGEX = /\\.[^.]+$/\n\nexport function buildSubsetFilename(sourceName: string, format: OutputFormat): string {\n  const base = (sourceName?.replace(EXTENSION_REGEX, '') || 'font').trim() || 'font'\n  return `subset-${base}.${format}`\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAO,MAAM,iBAAiB;IAC5B;QAAE,IAAI;QAAO,OAAO;IAAM;IAC1B;QAAE,IAAI;QAAS,OAAO;IAAQ;IAC9B;QAAE,IAAI;QAAQ,OAAO;IAAO;CAC7B;AAIM,MAAM,oBAAkD;IAC7D,KAAK;IACL,OAAO;IACP,MAAM;AACR;AAEO,MAAM,mBAAoE;IAC/E,KAAK;IACL,OAAO;IACP,MAAM;AACR;AAEO,MAAM,wBAAsC;AAE5C,SAAS,eAAe,KAAa;IAC1C,OAAO,eAAe,IAAI,CAAC,CAAC,SAAW,OAAO,EAAE,KAAK;AACvD;AAEA,MAAM,kBAAkB;AAEjB,SAAS,oBAAoB,UAAkB,EAAE,MAAoB;IAC1E,MAAM,OAAO,CAAC,YAAY,QAAQ,iBAAiB,OAAO,MAAM,EAAE,IAAI,MAAM;IAC5E,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE,QAAQ;AACnC"}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///Users/huyixi/i/font-subsetter/app/api/subset/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport subsetFont from \"subset-font\";\nimport {\n  DEFAULT_OUTPUT_FORMAT,\n  FORMAT_TO_TARGET,\n  OUTPUT_MIME_TYPES,\n  buildSubsetFilename,\n  isOutputFormat,\n  type OutputFormat,\n} from \"@/lib/outputFormats\";\n\nexport const runtime = \"nodejs\";\n\nconst MAX_CHARACTERS = 50000;\nconst MAX_FONT_BYTES = 20 * 1024 * 1024; // 20MB safety limit\n\nexport async function POST(request: Request) {\n  try {\n    const formData = await request.formData();\n    const fontEntry = formData.get(\"font\");\n    const characters = String(formData.get(\"characters\") ?? \"\").trim();\n    const formatEntry = formData.get(\"format\");\n\n    if (!(fontEntry instanceof File) || fontEntry.size === 0) {\n      return NextResponse.json(\n        { error: \"请上传要子集化的字体文件\" },\n        { status: 400 },\n      );\n    }\n\n    if (fontEntry.size > MAX_FONT_BYTES) {\n      return NextResponse.json(\n        { error: \"字体文件过大，请选择 20MB 以内的文件\" },\n        { status: 400 },\n      );\n    }\n\n    if (!characters) {\n      return NextResponse.json(\n        { error: \"请输入或选择要保留的字符\" },\n        { status: 400 },\n      );\n    }\n\n    if (characters.length > MAX_CHARACTERS) {\n      return NextResponse.json(\n        { error: \"字符数量过多，请控制在 50,000 个以内\" },\n        { status: 400 },\n      );\n    }\n\n    let outputFormat: OutputFormat = DEFAULT_OUTPUT_FORMAT;\n    if (typeof formatEntry === \"string\" && isOutputFormat(formatEntry)) {\n      outputFormat = formatEntry;\n    }\n\n    const fontBuffer = Buffer.from(await fontEntry.arrayBuffer());\n    const subsetBuffer = await subsetFont(fontBuffer, characters, {\n      targetFormat: FORMAT_TO_TARGET[outputFormat],\n    });\n\n    const filename = buildSubsetFilename(fontEntry.name, outputFormat);\n    const encodedFilename = encodeURIComponent(filename);\n\n    return new NextResponse(subsetBuffer, {\n      headers: {\n        \"Content-Type\": OUTPUT_MIME_TYPES[outputFormat],\n        \"Content-Length\": String(subsetBuffer.length),\n        \"Cache-Control\": \"no-store\",\n        \"Content-Disposition\": `attachment; filename=\"${encodedFilename}\"; filename*=UTF-8''${encodedFilename}`,\n      },\n    });\n  } catch (error) {\n    console.error(\"Font subset failed\", error);\n    return NextResponse.json(\n      { error: \"字体子集生成失败，请稍后再试\" },\n      { status: 500 },\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AASO,MAAM,UAAU;AAEvB,MAAM,iBAAiB;AACvB,MAAM,iBAAiB,KAAK,OAAO,MAAM,oBAAoB;AAEtD,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,YAAY,SAAS,GAAG,CAAC;QAC/B,MAAM,aAAa,OAAO,SAAS,GAAG,CAAC,iBAAiB,IAAI,IAAI;QAChE,MAAM,cAAc,SAAS,GAAG,CAAC;QAEjC,IAAI,CAAC,CAAC,qBAAqB,IAAI,KAAK,UAAU,IAAI,KAAK,GAAG;YACxD,OAAO,+QAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAe,GACxB;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,UAAU,IAAI,GAAG,gBAAgB;YACnC,OAAO,+QAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,CAAC,YAAY;YACf,OAAO,+QAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAe,GACxB;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,WAAW,MAAM,GAAG,gBAAgB;YACtC,OAAO,+QAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAyB,GAClC;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,eAA6B,+IAAqB;QACtD,IAAI,OAAO,gBAAgB,YAAY,IAAA,wIAAc,EAAC,cAAc;YAClE,eAAe;QACjB;QAEA,MAAM,aAAa,OAAO,IAAI,CAAC,MAAM,UAAU,WAAW;QAC1D,MAAM,eAAe,MAAM,IAAA,+MAAU,EAAC,YAAY,YAAY;YAC5D,cAAc,0IAAgB,CAAC,aAAa;QAC9C;QAEA,MAAM,WAAW,IAAA,6IAAmB,EAAC,UAAU,IAAI,EAAE;QACrD,MAAM,kBAAkB,mBAAmB;QAE3C,OAAO,IAAI,+QAAY,CAAC,cAAc;YACpC,SAAS;gBACP,gBAAgB,2IAAiB,CAAC,aAAa;gBAC/C,kBAAkB,OAAO,aAAa,MAAM;gBAC5C,iBAAiB;gBACjB,uBAAuB,CAAC,sBAAsB,EAAE,gBAAgB,oBAAoB,EAAE,iBAAiB;YACzG;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sBAAsB;QACpC,OAAO,+QAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAiB,GAC1B;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}