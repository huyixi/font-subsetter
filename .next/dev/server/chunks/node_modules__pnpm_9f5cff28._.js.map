{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///Users/huyixi/i/font-subsetter/node_modules/.pnpm/yocto-queue%400.1.0/node_modules/yocto-queue/index.js"],"sourcesContent":["class Node {\n\t/// value;\n\t/// next;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\n\t\t// TODO: Remove this when targeting Node.js 12.\n\t\tthis.next = undefined;\n\t}\n}\n\nclass Queue {\n\t// TODO: Use private class fields when targeting Node.js 12.\n\t// #_head;\n\t// #_tail;\n\t// #_size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this._head) {\n\t\t\tthis._tail.next = node;\n\t\t\tthis._tail = node;\n\t\t} else {\n\t\t\tthis._head = node;\n\t\t\tthis._tail = node;\n\t\t}\n\n\t\tthis._size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this._head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._head = this._head.next;\n\t\tthis._size--;\n\t\treturn current.value;\n\t}\n\n\tclear() {\n\t\tthis._head = undefined;\n\t\tthis._tail = undefined;\n\t\tthis._size = 0;\n\t}\n\n\tget size() {\n\t\treturn this._size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this._head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n\nmodule.exports = Queue;\n"],"names":[],"mappings":"AAAA,MAAM;IACL,UAAU;IACV,SAAS;IAET,YAAY,KAAK,CAAE;QAClB,IAAI,CAAC,KAAK,GAAG;QAEb,+CAA+C;QAC/C,IAAI,CAAC,IAAI,GAAG;IACb;AACD;AAEA,MAAM;IACL,4DAA4D;IAC5D,UAAU;IACV,UAAU;IACV,UAAU;IAEV,aAAc;QACb,IAAI,CAAC,KAAK;IACX;IAEA,QAAQ,KAAK,EAAE;QACd,MAAM,OAAO,IAAI,KAAK;QAEtB,IAAI,IAAI,CAAC,KAAK,EAAE;YACf,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG;YAClB,IAAI,CAAC,KAAK,GAAG;QACd,OAAO;YACN,IAAI,CAAC,KAAK,GAAG;YACb,IAAI,CAAC,KAAK,GAAG;QACd;QAEA,IAAI,CAAC,KAAK;IACX;IAEA,UAAU;QACT,MAAM,UAAU,IAAI,CAAC,KAAK;QAC1B,IAAI,CAAC,SAAS;YACb;QACD;QAEA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI;QAC5B,IAAI,CAAC,KAAK;QACV,OAAO,QAAQ,KAAK;IACrB;IAEA,QAAQ;QACP,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,KAAK,GAAG;IACd;IAEA,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,KAAK;IAClB;IAEA,CAAE,CAAC,OAAO,QAAQ,CAAC,GAAG;QACrB,IAAI,UAAU,IAAI,CAAC,KAAK;QAExB,MAAO,QAAS;YACf,MAAM,QAAQ,KAAK;YACnB,UAAU,QAAQ,IAAI;QACvB;IACD;AACD;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///Users/huyixi/i/font-subsetter/node_modules/.pnpm/p-limit%403.1.0/node_modules/p-limit/index.js"],"sourcesContent":["'use strict';\nconst Queue = require('yocto-queue');\n\nconst pLimit = concurrency => {\n\tif (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst run = async (fn, resolve, ...args) => {\n\t\tactiveCount++;\n\n\t\tconst result = (async () => fn(...args))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (fn, resolve, ...args) => {\n\t\tqueue.enqueue(run.bind(null, fn, resolve, ...args));\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// when the run function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\t\tqueue.dequeue()();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => {\n\t\tenqueue(fn, resolve, ...args);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.clear();\n\t\t\t}\n\t\t}\n\t});\n\n\treturn generator;\n};\n\nmodule.exports = pLimit;\n"],"names":[],"mappings":"AACA,MAAM;AAEN,MAAM,SAAS,CAAA;IACd,IAAI,CAAC,CAAC,CAAC,OAAO,SAAS,CAAC,gBAAgB,gBAAgB,QAAQ,KAAK,cAAc,CAAC,GAAG;QACtF,MAAM,IAAI,UAAU;IACrB;IAEA,MAAM,QAAQ,IAAI;IAClB,IAAI,cAAc;IAElB,MAAM,OAAO;QACZ;QAEA,IAAI,MAAM,IAAI,GAAG,GAAG;YACnB,MAAM,OAAO;QACd;IACD;IAEA,MAAM,MAAM,OAAO,IAAI,SAAS,GAAG;QAClC;QAEA,MAAM,SAAS,CAAC,UAAY,MAAM,KAAK;QAEvC,QAAQ;QAER,IAAI;YACH,MAAM;QACP,EAAE,OAAM,CAAC;QAET;IACD;IAEA,MAAM,UAAU,CAAC,IAAI,SAAS,GAAG;QAChC,MAAM,OAAO,CAAC,IAAI,IAAI,CAAC,MAAM,IAAI,YAAY;QAE7C,CAAC;YACA,wEAAwE;YACxE,kFAAkF;YAClF,mFAAmF;YACnF,uFAAuF;YACvF,MAAM,QAAQ,OAAO;YAErB,IAAI,cAAc,eAAe,MAAM,IAAI,GAAG,GAAG;gBAChD,MAAM,OAAO;YACd;QACD,CAAC;IACF;IAEA,MAAM,YAAY,CAAC,IAAI,GAAG,OAAS,IAAI,QAAQ,CAAA;YAC9C,QAAQ,IAAI,YAAY;QACzB;IAEA,OAAO,gBAAgB,CAAC,WAAW;QAClC,aAAa;YACZ,KAAK,IAAM;QACZ;QACA,cAAc;YACb,KAAK,IAAM,MAAM,IAAI;QACtB;QACA,YAAY;YACX,OAAO;gBACN,MAAM,KAAK;YACZ;QACD;IACD;IAEA,OAAO;AACR;AAEA,OAAO,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 119, "column": 0}, "map": {"version":3,"sources":["file:///Users/huyixi/i/font-subsetter/node_modules/.pnpm/woff2sfnt-sfnt2woff%401.0.0/node_modules/woff2sfnt-sfnt2woff/index.js"],"sourcesContent":["/**\n * Created by Onur Demiralay\n * MIT License Copyright(c) 2014 Onur Demiralay\n *\n * sfnt2woff & woff2sfnt converter based on http://people.mozilla.org/~jkew/woff/woff-2009-09-16.html\n */\n\n//TODO: Create test suites using Unit.js\n//TODO: Implement metadata and private data options. (Test these as well)\n\n\"use strict\";\nvar pako = require('pako');\n\n\n//given bit, do 4byte alignment by finding the nearest number that's divisible by 4.\nfunction fourByteAlign(bit) {\n    return (bit + 3) & ~ 3;\n}\n/* Validates 4bytealigned checksum against original checksum */\nfunction validateCheckSums(csum1, csum2) {\n    if(csum1 !== csum2) {\n        //console.log(\"mismatch!\");\n        throw 'Checksum Mismatch!';\n    }\n}\n/* 64-bit unsigned number emulator, if num overflow or underflow, it'll make the necessary adjustments.  */\nfunction convertULong(num) {\n    return num >>> 64;\n}\n\n/* Calculates checksum for 4byte aligned data */\nfunction calcCheckSum(tableDirEntry, sfntBuf) {\n    var offset = tableDirEntry.offset;\n    var length = fourByteAlign(tableDirEntry.length);\n    var csum = 0;\n    for (var i = 0; i < length; i += 4) {\n        var data =  sfntBuf.readUInt32BE(offset + i);\n        csum =  convertULong(data + csum); //((data + csum) % 0x100000000); //emulating unsigned 32 bit integer.\n    }\n    /* If it's the header, then find checksumadjustment and substract from checksumAdj to find the actual checksum. */\n    if (tableDirEntry.tag === 1751474532 || tableDirEntry.tag === 1651008868) { //1751474532 in decimal is 'head' in ascii 1651008868 is 'bhed' in decimal\n        var checkSumAdjustment = sfntBuf.readUInt32BE(offset + 2 * 4); //2nd val is the check sum adjustment\n        csum = convertULong(csum - checkSumAdjustment);\n    }\n    return csum;\n}\n/* Constructs the WOFF data by concatenating WOFF Buffers\n * Here's a top down structure: Header <- TableDir <- Table Data\n */\nfunction constructWOFF(WOFFHeader, WOFFTableDir, WOFFTableData, WOFFSize) {\n    var WOFF = Buffer.concat([WOFFHeader, WOFFTableDir]);\n    for (var i = 0; i < WOFFTableData.length; ++i) {\n        WOFF = Buffer.concat([WOFF, WOFFTableData[i]]);\n    }\n    /* Throw an exception if the WOFF's size doesn't match the size specified in the header */\n    if (WOFF.length !== WOFFSize) {\n        throw \"Error occurred while constructing WOFF! WOFF size doesn't match the size specified in the header! \" + WOFF.length + \" != \" + WOFFSize;\n    }\n    //console.log(WOFF.length + \" == \" + WOFFSize);\n    return WOFF;\n}\n\n/* Copies the contents of buf1 to buf2\n * This function assumes alignedLen will always be bigger or equal to buf's length.\n */\nfunction fourByteAlignedBuffer(buf, len) {\n    var alignedLen = fourByteAlign(len);\n    //console.log(\"long aligned length: \" + alignedLen);\n    var woffData = Buffer.alloc(alignedLen);\n    var zeroPaddedLen = alignedLen - buf.length;\n    for (var i = 0; i < buf.length; ++i) {\n        //console.log(buf[i]);\n        woffData[i] = buf[i];\n    }\n    //extra bytes zero padded\n    for (i = 0; i < zeroPaddedLen; ++i) {\n        woffData[buf.length + i] = 0;\n    }\n    return woffData;\n}\n\n/*The sfnt based font specifications require that the table directory entries are sorted in ascending order of tag value.\n* comparator function for sort() function.\n* */\nfunction tagComparison(entry1, entry2) {\n    var tag1Str = entry1.tag.toString();\n    var tag2Str = entry2.tag.toString();\n\n    if(tag1Str < tag2Str) {\n        return -1;\n    }\n    if (tag1Str > tag2Str) {\n        return 1;\n    }\n    return 0;\n}\n\n/* Constructs the WOFF Header, This version does not support metadata or private data.\n * if you wish to add support make sure to add necessary changes to the header\n * TODO: Find out if we're suppose to use sfnt versions as woff versions\n */\nfunction constructWOFFHeader(flavor, woffLen, numTables, totalSfntSize) {\n    var WOFF_HEADER_LENGTH = 44;\n    var WOFF_SIGNATURE = 0x774F4646;\n    var WOFFHeader = Buffer.alloc(WOFF_HEADER_LENGTH);\n\n    WOFFHeader.writeUInt32BE(WOFF_SIGNATURE,0); //Woff Signature\n    WOFFHeader.writeUInt32BE(flavor,4); //Flavor\n    WOFFHeader.writeUInt32BE(woffLen,8); //Woff Length\n    WOFFHeader.writeUInt16BE(numTables,12); //Woff Number of Tables\n    WOFFHeader.writeUInt16BE(0,14); //Woff Reserved (Always set to 0)\n    WOFFHeader.writeUInt32BE(totalSfntSize,16); //Woff Total SFNT Size\n    WOFFHeader.writeUInt16BE(0,20); //Woff Major Version\n    WOFFHeader.writeUInt16BE(0,22); //Woff Minor Version\n    WOFFHeader.writeUInt32BE(0,24); //Woff Meta Offset\n    WOFFHeader.writeUInt32BE(0,28); //Woff Meta Length\n    WOFFHeader.writeUInt32BE(0,32); //Woff Meta Original Length (uncompressed size of meta block)\n    WOFFHeader.writeUInt32BE(0,36); //Woff Private Offset\n    WOFFHeader.writeUInt32BE(0,40); //Woff Private Length\n    return WOFFHeader;\n}\n\n/* Given sfnt (.otf, .ttf) converts it to .woff format.\n * converter is based on http://people.mozilla.org/~jkew/woff/woff-2009-09-16.html\n * */\nfunction sfnt2woff(sfnt) {\n    var sfntBuffer = Buffer.from(sfnt);\n    var tableDirectory = [];\n\n    var SFNT_TABLE_DIR_SIZE = 16; /* 4byte for each tag, checksum, offset, length */\n    var SFNT_HEADER_LENGTH = 12; /* 2 byte for each numTables, searchRange, entrySelector, rangeShift, 4 byte for version*/\n    var WOFF_TABLE_DIR_SIZE = 20;\n    var WOFF_HEADER_LENGTH = 44;\n\n    var numTables = sfntBuffer.readUInt16BE(4);\n    var flavor = sfntBuffer.readUInt32BE(0);\n    var totalSfntSize = (numTables * SFNT_TABLE_DIR_SIZE) + SFNT_HEADER_LENGTH; //total expected size of decoded font.\n    //var checkSumAdjustment = 0;\n\n    /* Table directory entries start after sfnt header, each entry consist of tag, offset, length, checksum. */\n    for (var i = 0; i < numTables; ++i) {\n        var next = SFNT_HEADER_LENGTH + (i * SFNT_TABLE_DIR_SIZE);\n        //Read SFNT Table Directory entries\n        var tableDirectoryEntry = {\n            tag: sfntBuffer.readUInt32BE(next),\n            checksum: sfntBuffer.readUInt32BE(next + 4),\n            offset: sfntBuffer.readUInt32BE(next + 8),\n            length: sfntBuffer.readUInt32BE(next + 12)\n        };\n        /*\n         console.log(\"tag: \" + tableDirectoryEntry.tag.toString(16));\n         console.log(\"checksum: \" + tableDirectoryEntry.checksum.toString(16));\n         console.log(\"offset: \" + tableDirectoryEntry.offset.toString(16));\n         console.log(\"length: \" + tableDirectoryEntry.length.toString(16));\n         */\n        tableDirectory.push(tableDirectoryEntry);\n    }\n\n    /* This might not be needed, sfnt directory should already be sorted by tag. */\n    tableDirectory = tableDirectory.sort(tagComparison);\n\n    /* Table Directory Size = numTables * is calculated by multiplying the numTables value in the WOFF header times the size of a single WOFF table directory */\n    var woffTableSize = numTables * WOFF_TABLE_DIR_SIZE;\n    var woffTableOffset = WOFF_HEADER_LENGTH + woffTableSize; //table dir field starts right after header field.\n\n    var WOFFTableDir = Buffer.alloc(woffTableSize);\n    var WOFFTableData = []; //contains all the font data for every table.\n\n\n    /* construct WOFF Table Directory */\n    for (i = 0; i < numTables; ++i) {\n        tableDirectoryEntry = tableDirectory[i];\n\n        /* calculate checksum for each table and check for mismatch */\n        var csum = calcCheckSum(tableDirectoryEntry, sfntBuffer);\n        validateCheckSums(csum, tableDirectoryEntry.checksum);\n\n        /* sfnt header tag! */\n        /*\n         if (tableDirectoryEntry.tag === 1751474532 || tableDirectoryEntry.tag === 1651008868) {\n         //flavor = sfntBuffer.readUInt32BE(tableDirectoryEntry.offset); //won't work if it's otf\n         //checkSumAdjustment = sfntBuffer.readUInt32BE(tableDirectoryEntry.offset + 2 * 4);\n         } */\n        totalSfntSize += fourByteAlign(tableDirectoryEntry.length);\n        var end = tableDirectoryEntry.offset +  tableDirectoryEntry.length;\n        var start = tableDirectoryEntry.offset;\n\n        /* Slice the buffer to get the data for current table. */\n        var sfntSlice = sfntBuffer.slice(start, end);\n\n        //compress the data\n        var compSfntData = pako.deflate(sfntSlice);\n        var compLength = sfntSlice.length < compSfntData.length ? sfntSlice.length : compSfntData.length;\n        var woffDataEntry = fourByteAlignedBuffer(sfntSlice, compLength);\n\n        /* if compressed data is equal or larger than uncompressed, use uncompressed data. */\n        if (compSfntData.length >= sfntSlice.length) {\n            woffDataEntry = fourByteAlignedBuffer(sfntSlice, compLength);\n        } else {\n            woffDataEntry = fourByteAlignedBuffer(compSfntData, compLength);\n        }\n\n        /*Construct Woff Table Directory, WoffTableDir = tag, offset,  compressed length, length, checksum (in that order)*/\n        WOFFTableDir.writeUInt32BE(tableDirectoryEntry.tag, i* WOFF_TABLE_DIR_SIZE);\n        WOFFTableDir.writeUInt32BE(woffTableOffset, i* WOFF_TABLE_DIR_SIZE + 4);\n        WOFFTableDir.writeUInt32BE(compLength, i* WOFF_TABLE_DIR_SIZE + 8);\n        WOFFTableDir.writeUInt32BE(tableDirectoryEntry.length, i* WOFF_TABLE_DIR_SIZE + 12);\n        WOFFTableDir.writeUInt32BE(tableDirectoryEntry.checksum, i* WOFF_TABLE_DIR_SIZE + 16);\n\n        woffTableOffset += woffDataEntry.length; //update woff offset.\n        WOFFTableData.push(woffDataEntry);\n    }\n\n    //console.log(\"Flavor: \" + flavor);\n    //console.log(\"woffLen: \" + woffTableOffset);\n    //console.log(\"numTables: \" + numTables);\n    //console.log(\"totalSfntSize: \" + totalSfntSize);\n\n    var WOFFHeader = constructWOFFHeader(flavor, woffTableOffset, numTables, totalSfntSize);\n    var WOFF = constructWOFF(WOFFHeader,WOFFTableDir, WOFFTableData, woffTableOffset);\n    return WOFF;\n}\n/* Converts Woff to its original format (TTF or OTF) */\nfunction woff2sfnt(woff) {\n    var woffBuffer = Buffer.from(woff);\n    var tableDirectory = [];\n\n    var SFNT_HEADER_LENGTH = 12;\n    var SFNT_TABLE_DIR_SIZE = 16;\n    var WOFF_TABLE_DIR_SIZE = 20;\n    var WOFF_HEADER_LENGTH = 44;\n\n    /* Calculate necessary header fields. */\n    var numTables = woffBuffer.readUInt16BE(12);\n    var sfntVersion = woffBuffer.readUInt32BE(4); //woff flavor\n    var nearestPow2 = Math.pow(2, Math.floor(Math.log(numTables) / Math.log(2)));\n    var searchRange = nearestPow2 * 16;\n    var entrySelector = Math.log(nearestPow2) / Math.LN2;\n    var rangeShift = numTables * 16 - searchRange;\n\n    var SFNTHeader = constructSFNTHeader(sfntVersion, numTables, searchRange, entrySelector, rangeShift);\n\n    /* Table Directory Size = it's calculated by multiplying the numTables value in the SFNT header times the size of a single SFNT table directory */\n    var sfntTableSize = numTables * SFNT_TABLE_DIR_SIZE;\n    var sfntTableOffset = SFNT_HEADER_LENGTH; //table dir field starts right after header field.\n\n    for (var i = 0; i < numTables; ++i) {\n        var next = WOFF_HEADER_LENGTH + (i * WOFF_TABLE_DIR_SIZE);\n        //read WOFF directory entries\n        var tableDirectoryEntry = {\n            tag: woffBuffer.readUInt32BE(next),\n            offset: woffBuffer.readUInt32BE(next + 4),\n            compLen: woffBuffer.readUInt32BE(next + 8),\n            origLen: woffBuffer.readUInt32BE(next + 12),\n            origChecksum: woffBuffer.readUInt32BE(next + 16)\n        };\n        tableDirectory.push(tableDirectoryEntry);\n        sfntTableOffset += SFNT_TABLE_DIR_SIZE;\n    }\n    /* This might not be needed, sfnt directory should already be sorted by tag. */\n    tableDirectory = tableDirectory.sort(tagComparison);\n\n    var SFNTTableDir = Buffer.alloc(sfntTableSize);\n    var SFNTTableData = []; //contains all the font data for every table.\n    /* decompress the */\n    for (i = 0; i < numTables; ++i) {\n        tableDirectoryEntry = tableDirectory[i];\n        var start = tableDirectoryEntry.offset;\n        var end = tableDirectoryEntry.offset +  tableDirectoryEntry.compLen ;\n\n        /* Slice the buffer to get the data for current table. */\n        var woffSlice = woffBuffer.slice(start, end);\n        var sfntDataEntry;\n\n        /* if uncompressed data is not equal to compressed, then uncompress and use the data. */\n        if (tableDirectoryEntry.origLen != tableDirectoryEntry.compLen) {\n            //console.log(\"origLen != compLen: \" + tableDirectoryEntry.origLen + \" \" + tableDirectoryEntry.compLen);\n            sfntDataEntry = pako.inflate(woffSlice);\n            sfntDataEntry = toBuffer(sfntDataEntry);\n            //sfntDataEntry = new Buffer( new Uint8Array(sfntDataEntry) );\n        } else {\n            sfntDataEntry = woffSlice;\n        }\n\n        /* Construct Sfnt Table Directory, SFNTTableDir = tag, checksum, offset, length */\n        SFNTTableDir.writeUInt32BE(tableDirectoryEntry.tag, i * SFNT_TABLE_DIR_SIZE);\n        SFNTTableDir.writeUInt32BE(tableDirectoryEntry.origChecksum, i * SFNT_TABLE_DIR_SIZE + 4);\n        SFNTTableDir.writeUInt32BE(sfntTableOffset, i * SFNT_TABLE_DIR_SIZE + 8);\n        SFNTTableDir.writeUInt32BE(tableDirectoryEntry.origLen, i * SFNT_TABLE_DIR_SIZE + 12);\n\n        /* Check if we need to pad extra 0s (since woff data was 4byte aligned), if they are update sfnt offset accordingly. */\n        if (tableDirectoryEntry.origLen % 4 !== 0) {\n            sfntDataEntry = fourByteAlignedBuffer(sfntDataEntry,tableDirectoryEntry.origLen);\n            sfntTableOffset += sfntDataEntry.length;\n        } else {\n            sfntTableOffset += tableDirectoryEntry.origLen;\n        }\n\n        SFNTTableData.push(sfntDataEntry); //store table data\n    }\n\n    //console.log(sfntTableOffset);\n    //console.log(SFNTHeader.length);\n    //console.log(SFNTTableDir.length);\n    //console.log(SFNTTableData.length);\n    var SFNT  = constructSFNT(SFNTHeader, SFNTTableDir, SFNTTableData);\n    return SFNT;\n}\n\n/* Constructs the SFNT data by concatenating SFNT Buffers\n * Here's a top down structure: Header <- TableDir <- Table Data\n */\nfunction constructSFNT(SFNTHeader, SFNTTableDir, SFNTTableData) {\n    var SFNT = Buffer.concat([SFNTHeader, SFNTTableDir]);\n\n    for (var i = 0; i < SFNTTableData.length; ++i) {\n        SFNT = Buffer.concat([SFNT, SFNTTableData[i]]);\n    }\n    return SFNT;\n}\n\n\n\n/*Constructs SFNT Header */\nfunction constructSFNTHeader(sfntVersion, numTables, searchRange, entrySelector, rangeShift) {\n    var SFNT_HEADER_LENGTH = 12;\n    var SFNTHeader = Buffer.alloc(SFNT_HEADER_LENGTH);\n    SFNTHeader.writeInt32BE(sfntVersion,0); //SFNT Version\n    SFNTHeader.writeUInt16BE(numTables,4); //SFNT Number of Tables\n    SFNTHeader.writeUInt16BE(searchRange,6); //SFNT Search Range (Maximum power of 2 <= numTables) x 16.\n    SFNTHeader.writeUInt16BE(entrySelector,8); //SFNT Entry Selector (Log2(maximum power of 2 <= numTables).\n    SFNTHeader.writeUInt16BE(rangeShift,10); // SFNT Range Shift (NumTables x 16-searchRange.)\n    return SFNTHeader;\n}\n\n/* inflate function returns uint8array/arrayBuffer, this helper converts it back to buffer */\nfunction toBuffer(arrBuf) {\n    var buf = Buffer.alloc(arrBuf.byteLength);\n    var view = new Uint8Array(arrBuf);\n    for (var i = 0; i < buf.length; ++i) {\n        buf[i] = view[i];\n    }\n    return buf;\n}\n\n//module.exports = sfnt2woff;\nmodule.exports = {\n    toWoff: sfnt2woff,\n    toSfnt: woff2sfnt\n};"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 402, "column": 0}, "map": {"version":3,"sources":["file:///Users/huyixi/i/font-subsetter/node_modules/.pnpm/fontverter%402.0.0/node_modules/fontverter/index.js"],"sourcesContent":["const wawoff2 = require('wawoff2');\nconst woffTool = require('woff2sfnt-sfnt2woff');\n\nconst supportedFormats = new Set(['sfnt', 'woff', 'woff2']);\n\nexports.detectFormat = function (buffer) {\n  const signature = buffer.toString('ascii', 0, 4);\n  if (signature === 'wOFF') {\n    return 'woff';\n  } else if (signature === 'wOF2') {\n    return 'woff2';\n  } else if (\n    signature === 'true' ||\n    signature === 'OTTO' ||\n    signature === '\\x00\\x01\\x00\\x00'\n  ) {\n    return 'sfnt';\n  } else {\n    throw new Error(`Unrecognized font signature: ${signature}`);\n  }\n};\n\nexports.convert = async function (buffer, toFormat, fromFormat) {\n  if (toFormat === 'truetype') {\n    toFormat = 'sfnt';\n  }\n  if (fromFormat === 'truetype') {\n    fromFormat = 'sfnt';\n  }\n  if (!supportedFormats.has(toFormat)) {\n    throw new Error(`Unsupported target format: ${toFormat}`);\n  }\n  if (fromFormat) {\n    if (!supportedFormats.has(fromFormat)) {\n      throw new Error(`Unsupported source format: ${fromFormat}`);\n    }\n  } else {\n    fromFormat = exports.detectFormat(buffer);\n  }\n\n  if (fromFormat === toFormat) {\n    return buffer;\n  }\n  if (fromFormat === 'woff') {\n    buffer = woffTool.toSfnt(buffer);\n  } else if (fromFormat === 'woff2') {\n    buffer = Buffer.from(await wawoff2.decompress(buffer));\n  }\n\n  if (toFormat === 'woff') {\n    buffer = woffTool.toWoff(buffer);\n  } else if (toFormat === 'woff2') {\n    buffer = Buffer.from(await wawoff2.compress(buffer));\n  }\n  return buffer;\n};\n"],"names":[],"mappings":"AAAA,MAAM;AACN,MAAM;AAEN,MAAM,mBAAmB,IAAI,IAAI;IAAC;IAAQ;IAAQ;CAAQ;AAE1D,QAAQ,YAAY,GAAG,SAAU,MAAM;IACrC,MAAM,YAAY,OAAO,QAAQ,CAAC,SAAS,GAAG;IAC9C,IAAI,cAAc,QAAQ;QACxB,OAAO;IACT,OAAO,IAAI,cAAc,QAAQ;QAC/B,OAAO;IACT,OAAO,IACL,cAAc,UACd,cAAc,UACd,cAAc,oBACd;QACA,OAAO;IACT,OAAO;QACL,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,WAAW;IAC7D;AACF;AAEA,QAAQ,OAAO,GAAG,eAAgB,MAAM,EAAE,QAAQ,EAAE,UAAU;IAC5D,IAAI,aAAa,YAAY;QAC3B,WAAW;IACb;IACA,IAAI,eAAe,YAAY;QAC7B,aAAa;IACf;IACA,IAAI,CAAC,iBAAiB,GAAG,CAAC,WAAW;QACnC,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,UAAU;IAC1D;IACA,IAAI,YAAY;QACd,IAAI,CAAC,iBAAiB,GAAG,CAAC,aAAa;YACrC,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,YAAY;QAC5D;IACF,OAAO;QACL,aAAa,QAAQ,YAAY,CAAC;IACpC;IAEA,IAAI,eAAe,UAAU;QAC3B,OAAO;IACT;IACA,IAAI,eAAe,QAAQ;QACzB,SAAS,SAAS,MAAM,CAAC;IAC3B,OAAO,IAAI,eAAe,SAAS;QACjC,SAAS,OAAO,IAAI,CAAC,MAAM,QAAQ,UAAU,CAAC;IAChD;IAEA,IAAI,aAAa,QAAQ;QACvB,SAAS,SAAS,MAAM,CAAC;IAC3B,OAAO,IAAI,aAAa,SAAS;QAC/B,SAAS,OAAO,IAAI,CAAC,MAAM,QAAQ,QAAQ,CAAC;IAC9C;IACA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///Users/huyixi/i/font-subsetter/node_modules/.pnpm/harfbuzzjs%400.4.13/node_modules/harfbuzzjs/hb-subset.wasm_.loader.mjs"],"sourcesContent":["import wasmPath from \"WASM_PATH\";\n\nconst { memory, free, __indirect_function_table, hb_blob_create, hb_blob_destroy, malloc, hb_blob_get_length, hb_blob_get_data, hb_face_get_empty, hb_face_create, hb_face_destroy, hb_face_reference_blob, hb_set_create, hb_set_destroy, hb_set_clear, hb_set_add, hb_set_del, hb_set_union, hb_set_invert, hb_subset_input_create_or_fail, hb_subset_input_destroy, hb_subset_input_reference, hb_subset_input_unicode_set, hb_subset_input_glyph_set, hb_subset_input_set, hb_subset_input_get_flags, hb_subset_input_set_flags, hb_subset_input_set_user_data, hb_subset_input_get_user_data, hb_subset_input_keep_everything, hb_subset_input_pin_all_axes_to_default, hb_subset_input_pin_axis_to_default, hb_subset_input_pin_axis_location, hb_subset_input_set_axis_range, hb_subset_preprocess, hb_subset_or_fail, _initialize, _emscripten_stack_restore, emscripten_stack_get_current } = await __turbopack_wasm__(wasmPath, () => wasm_5fb6bd81a4c8b3ba, {}\n);\n\nexport { memory, free, __indirect_function_table, hb_blob_create, hb_blob_destroy, malloc, hb_blob_get_length, hb_blob_get_data, hb_face_get_empty, hb_face_create, hb_face_destroy, hb_face_reference_blob, hb_set_create, hb_set_destroy, hb_set_clear, hb_set_add, hb_set_del, hb_set_union, hb_set_invert, hb_subset_input_create_or_fail, hb_subset_input_destroy, hb_subset_input_reference, hb_subset_input_unicode_set, hb_subset_input_glyph_set, hb_subset_input_set, hb_subset_input_get_flags, hb_subset_input_set_flags, hb_subset_input_set_user_data, hb_subset_input_get_user_data, hb_subset_input_keep_everything, hb_subset_input_pin_all_axes_to_default, hb_subset_input_pin_axis_to_default, hb_subset_input_pin_axis_location, hb_subset_input_set_axis_range, hb_subset_preprocess, hb_subset_or_fail, _initialize, _emscripten_stack_restore, emscripten_stack_get_current };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEA,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,yBAAyB,EAAE,cAAc,EAAE,eAAe,EAAE,MAAM,EAAE,kBAAkB,EAAE,gBAAgB,EAAE,iBAAiB,EAAE,cAAc,EAAE,eAAe,EAAE,sBAAsB,EAAE,aAAa,EAAE,cAAc,EAAE,YAAY,EAAE,UAAU,EAAE,UAAU,EAAE,YAAY,EAAE,aAAa,EAAE,8BAA8B,EAAE,uBAAuB,EAAE,yBAAyB,EAAE,2BAA2B,EAAE,yBAAyB,EAAE,mBAAmB,EAAE,yBAAyB,EAAE,yBAAyB,EAAE,6BAA6B,EAAE,6BAA6B,EAAE,+BAA+B,EAAE,uCAAuC,EAAE,mCAAmC,EAAE,iCAAiC,EAAE,8BAA8B,EAAE,oBAAoB,EAAE,iBAAiB,EAAE,WAAW,EAAE,yBAAyB,EAAE,4BAA4B,EAAE,GAAG,MAAM,yDAAmB,gNAAQ,EAAE,IAAM,uBAAuB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 550, "column": 0}, "map": {"version":3,"sources":["file:///Users/huyixi/i/font-subsetter/node_modules/.pnpm/subset-font%402.4.0/node_modules/subset-font/index.js"],"sourcesContent":["/* global WebAssembly */\nconst { readFile } = require('fs').promises;\nconst _ = require('lodash');\nconst fontverter = require('fontverter');\n\nconst loadAndInitializeHarfbuzz = _.once(async () => {\n  const {\n    instance: { exports: harfbuzzJsWasm },\n  } = await WebAssembly.instantiate(\n    await readFile(require.resolve('harfbuzzjs/hb-subset.wasm'))\n  );\n\n  const heapu8 = new Uint8Array(harfbuzzJsWasm.memory.buffer);\n  return { harfbuzzJsWasm, heapu8 };\n});\n\nfunction HB_TAG(str) {\n  return str.split('').reduce(function (a, ch) {\n    return (a << 8) + ch.charCodeAt(0);\n  }, 0);\n}\n\nasync function subsetFont(\n  originalFont,\n  text,\n  {\n    targetFormat = fontverter.detectFormat(originalFont),\n    preserveNameIds,\n    variationAxes,\n    noLayoutClosure,\n  } = {}\n) {\n  if (typeof text !== 'string') {\n    throw new Error('The subset text must be given as a string');\n  }\n\n  const { harfbuzzJsWasm, heapu8 } = await loadAndInitializeHarfbuzz();\n\n  originalFont = await fontverter.convert(originalFont, 'truetype');\n\n  const input = harfbuzzJsWasm.hb_subset_input_create_or_fail();\n  if (input === 0) {\n    throw new Error(\n      'hb_subset_input_create_or_fail (harfbuzz) returned zero, indicating failure'\n    );\n  }\n\n  const fontBuffer = harfbuzzJsWasm.malloc(originalFont.byteLength);\n  heapu8.set(new Uint8Array(originalFont), fontBuffer);\n\n  // Create the face\n  const blob = harfbuzzJsWasm.hb_blob_create(\n    fontBuffer,\n    originalFont.byteLength,\n    2, // HB_MEMORY_MODE_WRITABLE\n    0,\n    0\n  );\n  const face = harfbuzzJsWasm.hb_face_create(blob, 0);\n  harfbuzzJsWasm.hb_blob_destroy(blob);\n\n  // Do the equivalent of --font-features=*\n  const layoutFeatures = harfbuzzJsWasm.hb_subset_input_set(\n    input,\n    6 // HB_SUBSET_SETS_LAYOUT_FEATURE_TAG\n  );\n  harfbuzzJsWasm.hb_set_clear(layoutFeatures);\n  harfbuzzJsWasm.hb_set_invert(layoutFeatures);\n\n  if (preserveNameIds) {\n    const inputNameIds = harfbuzzJsWasm.hb_subset_input_set(\n      input,\n      4 // HB_SUBSET_SETS_NAME_ID\n    );\n    for (const nameId of preserveNameIds) {\n      harfbuzzJsWasm.hb_set_add(inputNameIds, nameId);\n    }\n  }\n\n  if (noLayoutClosure) {\n    harfbuzzJsWasm.hb_subset_input_set_flags(\n      input,\n      harfbuzzJsWasm.hb_subset_input_get_flags(input) | 0x00000200 // HB_SUBSET_FLAGS_NO_LAYOUT_CLOSURE\n    );\n  }\n\n  // Add unicodes indices\n  const inputUnicodes = harfbuzzJsWasm.hb_subset_input_unicode_set(input);\n  for (const c of text) {\n    harfbuzzJsWasm.hb_set_add(inputUnicodes, c.codePointAt(0));\n  }\n\n  if (variationAxes) {\n    for (const [axisName, value] of Object.entries(variationAxes)) {\n      if (typeof value === 'number') {\n        // Simple case: Pin/instance the variation axis to a single value\n        if (\n          !harfbuzzJsWasm.hb_subset_input_pin_axis_location(\n            input,\n            face,\n            HB_TAG(axisName),\n            value\n          )\n        ) {\n          harfbuzzJsWasm.hb_face_destroy(face);\n          harfbuzzJsWasm.free(fontBuffer);\n          throw new Error(\n            `hb_subset_input_pin_axis_location (harfbuzz) returned zero when pinning ${axisName} to ${value}, indicating failure. Maybe the axis does not exist in the font?`\n          );\n        }\n      } else if (value && typeof value === 'object') {\n        // Complex case: Reduce the variation space of the axis\n        if (\n          typeof value.min === 'undefined' ||\n          typeof value.max === 'undefined'\n        ) {\n          harfbuzzJsWasm.hb_face_destroy(face);\n          harfbuzzJsWasm.free(fontBuffer);\n          throw new Error(\n            `${axisName}: You must provide both a min and a max value when setting the axis range`\n          );\n        }\n        if (\n          !harfbuzzJsWasm.hb_subset_input_set_axis_range(\n            input,\n            face,\n            HB_TAG(axisName),\n            value.min,\n            value.max,\n            // An explicit NaN makes harfbuzz use the existing default value, clamping to the new range if necessary\n            value.default ?? NaN\n          )\n        ) {\n          harfbuzzJsWasm.hb_face_destroy(face);\n          harfbuzzJsWasm.free(fontBuffer);\n          throw new Error(\n            `hb_subset_input_set_axis_range (harfbuzz) returned zero when setting the range of ${axisName} to [${value.min}; ${value.max}] and a default value of ${value.default}, indicating failure. Maybe the axis does not exist in the font?`\n          );\n        }\n      }\n    }\n  }\n\n  let subset;\n  try {\n    subset = harfbuzzJsWasm.hb_subset_or_fail(face, input);\n    if (subset === 0) {\n      harfbuzzJsWasm.hb_face_destroy(face);\n      harfbuzzJsWasm.free(fontBuffer);\n      throw new Error(\n        'hb_subset_or_fail (harfbuzz) returned zero, indicating failure. Maybe the input file is corrupted?'\n      );\n    }\n  } finally {\n    // Clean up\n    harfbuzzJsWasm.hb_subset_input_destroy(input);\n  }\n\n  // Get result blob\n  const result = harfbuzzJsWasm.hb_face_reference_blob(subset);\n\n  const offset = harfbuzzJsWasm.hb_blob_get_data(result, 0);\n  const subsetByteLength = harfbuzzJsWasm.hb_blob_get_length(result);\n  if (subsetByteLength === 0) {\n    harfbuzzJsWasm.hb_blob_destroy(result);\n    harfbuzzJsWasm.hb_face_destroy(subset);\n    harfbuzzJsWasm.hb_face_destroy(face);\n    harfbuzzJsWasm.free(fontBuffer);\n    throw new Error(\n      'Failed to create subset font, maybe the input file is corrupted?'\n    );\n  }\n\n  const subsetFont = Buffer.from(\n    heapu8.subarray(offset, offset + subsetByteLength)\n  );\n\n  // Clean up\n  harfbuzzJsWasm.hb_blob_destroy(result);\n  harfbuzzJsWasm.hb_face_destroy(subset);\n  harfbuzzJsWasm.hb_face_destroy(face);\n  harfbuzzJsWasm.free(fontBuffer);\n\n  return await fontverter.convert(subsetFont, targetFormat, 'truetype');\n}\n\nconst limiter = require('p-limit')(1);\nmodule.exports = (...args) => limiter(() => subsetFont(...args));\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}