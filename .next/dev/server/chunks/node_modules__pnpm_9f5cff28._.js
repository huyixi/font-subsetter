module.exports = [
"[project]/node_modules/.pnpm/yocto-queue@0.1.0/node_modules/yocto-queue/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

class Node {
    /// value;
    /// next;
    constructor(value){
        this.value = value;
        // TODO: Remove this when targeting Node.js 12.
        this.next = undefined;
    }
}
class Queue {
    // TODO: Use private class fields when targeting Node.js 12.
    // #_head;
    // #_tail;
    // #_size;
    constructor(){
        this.clear();
    }
    enqueue(value) {
        const node = new Node(value);
        if (this._head) {
            this._tail.next = node;
            this._tail = node;
        } else {
            this._head = node;
            this._tail = node;
        }
        this._size++;
    }
    dequeue() {
        const current = this._head;
        if (!current) {
            return;
        }
        this._head = this._head.next;
        this._size--;
        return current.value;
    }
    clear() {
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
    }
    get size() {
        return this._size;
    }
    *[Symbol.iterator]() {
        let current = this._head;
        while(current){
            yield current.value;
            current = current.next;
        }
    }
}
module.exports = Queue;
}),
"[project]/node_modules/.pnpm/p-limit@3.1.0/node_modules/p-limit/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Queue = __turbopack_context__.r("[project]/node_modules/.pnpm/yocto-queue@0.1.0/node_modules/yocto-queue/index.js [app-route] (ecmascript)");
const pLimit = (concurrency)=>{
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        throw new TypeError('Expected `concurrency` to be a number from 1 and up');
    }
    const queue = new Queue();
    let activeCount = 0;
    const next = ()=>{
        activeCount--;
        if (queue.size > 0) {
            queue.dequeue()();
        }
    };
    const run = async (fn, resolve, ...args)=>{
        activeCount++;
        const result = (async ()=>fn(...args))();
        resolve(result);
        try {
            await result;
        } catch  {}
        next();
    };
    const enqueue = (fn, resolve, ...args)=>{
        queue.enqueue(run.bind(null, fn, resolve, ...args));
        (async ()=>{
            // This function needs to wait until the next microtask before comparing
            // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
            // when the run function is dequeued and called. The comparison in the if-statement
            // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
            await Promise.resolve();
            if (activeCount < concurrency && queue.size > 0) {
                queue.dequeue()();
            }
        })();
    };
    const generator = (fn, ...args)=>new Promise((resolve)=>{
            enqueue(fn, resolve, ...args);
        });
    Object.defineProperties(generator, {
        activeCount: {
            get: ()=>activeCount
        },
        pendingCount: {
            get: ()=>queue.size
        },
        clearQueue: {
            value: ()=>{
                queue.clear();
            }
        }
    });
    return generator;
};
module.exports = pLimit;
}),
"[project]/node_modules/.pnpm/woff2sfnt-sfnt2woff@1.0.0/node_modules/woff2sfnt-sfnt2woff/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Created by Onur Demiralay
 * MIT License Copyright(c) 2014 Onur Demiralay
 *
 * sfnt2woff & woff2sfnt converter based on http://people.mozilla.org/~jkew/woff/woff-2009-09-16.html
 */ //TODO: Create test suites using Unit.js
//TODO: Implement metadata and private data options. (Test these as well)
var pako = __turbopack_context__.r("[project]/node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js [app-route] (ecmascript)");
//given bit, do 4byte alignment by finding the nearest number that's divisible by 4.
function fourByteAlign(bit) {
    return bit + 3 & ~3;
}
/* Validates 4bytealigned checksum against original checksum */ function validateCheckSums(csum1, csum2) {
    if (csum1 !== csum2) {
        //console.log("mismatch!");
        throw 'Checksum Mismatch!';
    }
}
/* 64-bit unsigned number emulator, if num overflow or underflow, it'll make the necessary adjustments.  */ function convertULong(num) {
    return num >>> 64;
}
/* Calculates checksum for 4byte aligned data */ function calcCheckSum(tableDirEntry, sfntBuf) {
    var offset = tableDirEntry.offset;
    var length = fourByteAlign(tableDirEntry.length);
    var csum = 0;
    for(var i = 0; i < length; i += 4){
        var data = sfntBuf.readUInt32BE(offset + i);
        csum = convertULong(data + csum); //((data + csum) % 0x100000000); //emulating unsigned 32 bit integer.
    }
    /* If it's the header, then find checksumadjustment and substract from checksumAdj to find the actual checksum. */ if (tableDirEntry.tag === 1751474532 || tableDirEntry.tag === 1651008868) {
        var checkSumAdjustment = sfntBuf.readUInt32BE(offset + 2 * 4); //2nd val is the check sum adjustment
        csum = convertULong(csum - checkSumAdjustment);
    }
    return csum;
}
/* Constructs the WOFF data by concatenating WOFF Buffers
 * Here's a top down structure: Header <- TableDir <- Table Data
 */ function constructWOFF(WOFFHeader, WOFFTableDir, WOFFTableData, WOFFSize) {
    var WOFF = Buffer.concat([
        WOFFHeader,
        WOFFTableDir
    ]);
    for(var i = 0; i < WOFFTableData.length; ++i){
        WOFF = Buffer.concat([
            WOFF,
            WOFFTableData[i]
        ]);
    }
    /* Throw an exception if the WOFF's size doesn't match the size specified in the header */ if (WOFF.length !== WOFFSize) {
        throw "Error occurred while constructing WOFF! WOFF size doesn't match the size specified in the header! " + WOFF.length + " != " + WOFFSize;
    }
    //console.log(WOFF.length + " == " + WOFFSize);
    return WOFF;
}
/* Copies the contents of buf1 to buf2
 * This function assumes alignedLen will always be bigger or equal to buf's length.
 */ function fourByteAlignedBuffer(buf, len) {
    var alignedLen = fourByteAlign(len);
    //console.log("long aligned length: " + alignedLen);
    var woffData = Buffer.alloc(alignedLen);
    var zeroPaddedLen = alignedLen - buf.length;
    for(var i = 0; i < buf.length; ++i){
        //console.log(buf[i]);
        woffData[i] = buf[i];
    }
    //extra bytes zero padded
    for(i = 0; i < zeroPaddedLen; ++i){
        woffData[buf.length + i] = 0;
    }
    return woffData;
}
/*The sfnt based font specifications require that the table directory entries are sorted in ascending order of tag value.
* comparator function for sort() function.
* */ function tagComparison(entry1, entry2) {
    var tag1Str = entry1.tag.toString();
    var tag2Str = entry2.tag.toString();
    if (tag1Str < tag2Str) {
        return -1;
    }
    if (tag1Str > tag2Str) {
        return 1;
    }
    return 0;
}
/* Constructs the WOFF Header, This version does not support metadata or private data.
 * if you wish to add support make sure to add necessary changes to the header
 * TODO: Find out if we're suppose to use sfnt versions as woff versions
 */ function constructWOFFHeader(flavor, woffLen, numTables, totalSfntSize) {
    var WOFF_HEADER_LENGTH = 44;
    var WOFF_SIGNATURE = 0x774F4646;
    var WOFFHeader = Buffer.alloc(WOFF_HEADER_LENGTH);
    WOFFHeader.writeUInt32BE(WOFF_SIGNATURE, 0); //Woff Signature
    WOFFHeader.writeUInt32BE(flavor, 4); //Flavor
    WOFFHeader.writeUInt32BE(woffLen, 8); //Woff Length
    WOFFHeader.writeUInt16BE(numTables, 12); //Woff Number of Tables
    WOFFHeader.writeUInt16BE(0, 14); //Woff Reserved (Always set to 0)
    WOFFHeader.writeUInt32BE(totalSfntSize, 16); //Woff Total SFNT Size
    WOFFHeader.writeUInt16BE(0, 20); //Woff Major Version
    WOFFHeader.writeUInt16BE(0, 22); //Woff Minor Version
    WOFFHeader.writeUInt32BE(0, 24); //Woff Meta Offset
    WOFFHeader.writeUInt32BE(0, 28); //Woff Meta Length
    WOFFHeader.writeUInt32BE(0, 32); //Woff Meta Original Length (uncompressed size of meta block)
    WOFFHeader.writeUInt32BE(0, 36); //Woff Private Offset
    WOFFHeader.writeUInt32BE(0, 40); //Woff Private Length
    return WOFFHeader;
}
/* Given sfnt (.otf, .ttf) converts it to .woff format.
 * converter is based on http://people.mozilla.org/~jkew/woff/woff-2009-09-16.html
 * */ function sfnt2woff(sfnt) {
    var sfntBuffer = Buffer.from(sfnt);
    var tableDirectory = [];
    var SFNT_TABLE_DIR_SIZE = 16; /* 4byte for each tag, checksum, offset, length */ 
    var SFNT_HEADER_LENGTH = 12; /* 2 byte for each numTables, searchRange, entrySelector, rangeShift, 4 byte for version*/ 
    var WOFF_TABLE_DIR_SIZE = 20;
    var WOFF_HEADER_LENGTH = 44;
    var numTables = sfntBuffer.readUInt16BE(4);
    var flavor = sfntBuffer.readUInt32BE(0);
    var totalSfntSize = numTables * SFNT_TABLE_DIR_SIZE + SFNT_HEADER_LENGTH; //total expected size of decoded font.
    //var checkSumAdjustment = 0;
    /* Table directory entries start after sfnt header, each entry consist of tag, offset, length, checksum. */ for(var i = 0; i < numTables; ++i){
        var next = SFNT_HEADER_LENGTH + i * SFNT_TABLE_DIR_SIZE;
        //Read SFNT Table Directory entries
        var tableDirectoryEntry = {
            tag: sfntBuffer.readUInt32BE(next),
            checksum: sfntBuffer.readUInt32BE(next + 4),
            offset: sfntBuffer.readUInt32BE(next + 8),
            length: sfntBuffer.readUInt32BE(next + 12)
        };
        /*
         console.log("tag: " + tableDirectoryEntry.tag.toString(16));
         console.log("checksum: " + tableDirectoryEntry.checksum.toString(16));
         console.log("offset: " + tableDirectoryEntry.offset.toString(16));
         console.log("length: " + tableDirectoryEntry.length.toString(16));
         */ tableDirectory.push(tableDirectoryEntry);
    }
    /* This might not be needed, sfnt directory should already be sorted by tag. */ tableDirectory = tableDirectory.sort(tagComparison);
    /* Table Directory Size = numTables * is calculated by multiplying the numTables value in the WOFF header times the size of a single WOFF table directory */ var woffTableSize = numTables * WOFF_TABLE_DIR_SIZE;
    var woffTableOffset = WOFF_HEADER_LENGTH + woffTableSize; //table dir field starts right after header field.
    var WOFFTableDir = Buffer.alloc(woffTableSize);
    var WOFFTableData = []; //contains all the font data for every table.
    /* construct WOFF Table Directory */ for(i = 0; i < numTables; ++i){
        tableDirectoryEntry = tableDirectory[i];
        /* calculate checksum for each table and check for mismatch */ var csum = calcCheckSum(tableDirectoryEntry, sfntBuffer);
        validateCheckSums(csum, tableDirectoryEntry.checksum);
        /* sfnt header tag! */ /*
         if (tableDirectoryEntry.tag === 1751474532 || tableDirectoryEntry.tag === 1651008868) {
         //flavor = sfntBuffer.readUInt32BE(tableDirectoryEntry.offset); //won't work if it's otf
         //checkSumAdjustment = sfntBuffer.readUInt32BE(tableDirectoryEntry.offset + 2 * 4);
         } */ totalSfntSize += fourByteAlign(tableDirectoryEntry.length);
        var end = tableDirectoryEntry.offset + tableDirectoryEntry.length;
        var start = tableDirectoryEntry.offset;
        /* Slice the buffer to get the data for current table. */ var sfntSlice = sfntBuffer.slice(start, end);
        //compress the data
        var compSfntData = pako.deflate(sfntSlice);
        var compLength = sfntSlice.length < compSfntData.length ? sfntSlice.length : compSfntData.length;
        var woffDataEntry = fourByteAlignedBuffer(sfntSlice, compLength);
        /* if compressed data is equal or larger than uncompressed, use uncompressed data. */ if (compSfntData.length >= sfntSlice.length) {
            woffDataEntry = fourByteAlignedBuffer(sfntSlice, compLength);
        } else {
            woffDataEntry = fourByteAlignedBuffer(compSfntData, compLength);
        }
        /*Construct Woff Table Directory, WoffTableDir = tag, offset,  compressed length, length, checksum (in that order)*/ WOFFTableDir.writeUInt32BE(tableDirectoryEntry.tag, i * WOFF_TABLE_DIR_SIZE);
        WOFFTableDir.writeUInt32BE(woffTableOffset, i * WOFF_TABLE_DIR_SIZE + 4);
        WOFFTableDir.writeUInt32BE(compLength, i * WOFF_TABLE_DIR_SIZE + 8);
        WOFFTableDir.writeUInt32BE(tableDirectoryEntry.length, i * WOFF_TABLE_DIR_SIZE + 12);
        WOFFTableDir.writeUInt32BE(tableDirectoryEntry.checksum, i * WOFF_TABLE_DIR_SIZE + 16);
        woffTableOffset += woffDataEntry.length; //update woff offset.
        WOFFTableData.push(woffDataEntry);
    }
    //console.log("Flavor: " + flavor);
    //console.log("woffLen: " + woffTableOffset);
    //console.log("numTables: " + numTables);
    //console.log("totalSfntSize: " + totalSfntSize);
    var WOFFHeader = constructWOFFHeader(flavor, woffTableOffset, numTables, totalSfntSize);
    var WOFF = constructWOFF(WOFFHeader, WOFFTableDir, WOFFTableData, woffTableOffset);
    return WOFF;
}
/* Converts Woff to its original format (TTF or OTF) */ function woff2sfnt(woff) {
    var woffBuffer = Buffer.from(woff);
    var tableDirectory = [];
    var SFNT_HEADER_LENGTH = 12;
    var SFNT_TABLE_DIR_SIZE = 16;
    var WOFF_TABLE_DIR_SIZE = 20;
    var WOFF_HEADER_LENGTH = 44;
    /* Calculate necessary header fields. */ var numTables = woffBuffer.readUInt16BE(12);
    var sfntVersion = woffBuffer.readUInt32BE(4); //woff flavor
    var nearestPow2 = Math.pow(2, Math.floor(Math.log(numTables) / Math.log(2)));
    var searchRange = nearestPow2 * 16;
    var entrySelector = Math.log(nearestPow2) / Math.LN2;
    var rangeShift = numTables * 16 - searchRange;
    var SFNTHeader = constructSFNTHeader(sfntVersion, numTables, searchRange, entrySelector, rangeShift);
    /* Table Directory Size = it's calculated by multiplying the numTables value in the SFNT header times the size of a single SFNT table directory */ var sfntTableSize = numTables * SFNT_TABLE_DIR_SIZE;
    var sfntTableOffset = SFNT_HEADER_LENGTH; //table dir field starts right after header field.
    for(var i = 0; i < numTables; ++i){
        var next = WOFF_HEADER_LENGTH + i * WOFF_TABLE_DIR_SIZE;
        //read WOFF directory entries
        var tableDirectoryEntry = {
            tag: woffBuffer.readUInt32BE(next),
            offset: woffBuffer.readUInt32BE(next + 4),
            compLen: woffBuffer.readUInt32BE(next + 8),
            origLen: woffBuffer.readUInt32BE(next + 12),
            origChecksum: woffBuffer.readUInt32BE(next + 16)
        };
        tableDirectory.push(tableDirectoryEntry);
        sfntTableOffset += SFNT_TABLE_DIR_SIZE;
    }
    /* This might not be needed, sfnt directory should already be sorted by tag. */ tableDirectory = tableDirectory.sort(tagComparison);
    var SFNTTableDir = Buffer.alloc(sfntTableSize);
    var SFNTTableData = []; //contains all the font data for every table.
    /* decompress the */ for(i = 0; i < numTables; ++i){
        tableDirectoryEntry = tableDirectory[i];
        var start = tableDirectoryEntry.offset;
        var end = tableDirectoryEntry.offset + tableDirectoryEntry.compLen;
        /* Slice the buffer to get the data for current table. */ var woffSlice = woffBuffer.slice(start, end);
        var sfntDataEntry;
        /* if uncompressed data is not equal to compressed, then uncompress and use the data. */ if (tableDirectoryEntry.origLen != tableDirectoryEntry.compLen) {
            //console.log("origLen != compLen: " + tableDirectoryEntry.origLen + " " + tableDirectoryEntry.compLen);
            sfntDataEntry = pako.inflate(woffSlice);
            sfntDataEntry = toBuffer(sfntDataEntry);
        //sfntDataEntry = new Buffer( new Uint8Array(sfntDataEntry) );
        } else {
            sfntDataEntry = woffSlice;
        }
        /* Construct Sfnt Table Directory, SFNTTableDir = tag, checksum, offset, length */ SFNTTableDir.writeUInt32BE(tableDirectoryEntry.tag, i * SFNT_TABLE_DIR_SIZE);
        SFNTTableDir.writeUInt32BE(tableDirectoryEntry.origChecksum, i * SFNT_TABLE_DIR_SIZE + 4);
        SFNTTableDir.writeUInt32BE(sfntTableOffset, i * SFNT_TABLE_DIR_SIZE + 8);
        SFNTTableDir.writeUInt32BE(tableDirectoryEntry.origLen, i * SFNT_TABLE_DIR_SIZE + 12);
        /* Check if we need to pad extra 0s (since woff data was 4byte aligned), if they are update sfnt offset accordingly. */ if (tableDirectoryEntry.origLen % 4 !== 0) {
            sfntDataEntry = fourByteAlignedBuffer(sfntDataEntry, tableDirectoryEntry.origLen);
            sfntTableOffset += sfntDataEntry.length;
        } else {
            sfntTableOffset += tableDirectoryEntry.origLen;
        }
        SFNTTableData.push(sfntDataEntry); //store table data
    }
    //console.log(sfntTableOffset);
    //console.log(SFNTHeader.length);
    //console.log(SFNTTableDir.length);
    //console.log(SFNTTableData.length);
    var SFNT = constructSFNT(SFNTHeader, SFNTTableDir, SFNTTableData);
    return SFNT;
}
/* Constructs the SFNT data by concatenating SFNT Buffers
 * Here's a top down structure: Header <- TableDir <- Table Data
 */ function constructSFNT(SFNTHeader, SFNTTableDir, SFNTTableData) {
    var SFNT = Buffer.concat([
        SFNTHeader,
        SFNTTableDir
    ]);
    for(var i = 0; i < SFNTTableData.length; ++i){
        SFNT = Buffer.concat([
            SFNT,
            SFNTTableData[i]
        ]);
    }
    return SFNT;
}
/*Constructs SFNT Header */ function constructSFNTHeader(sfntVersion, numTables, searchRange, entrySelector, rangeShift) {
    var SFNT_HEADER_LENGTH = 12;
    var SFNTHeader = Buffer.alloc(SFNT_HEADER_LENGTH);
    SFNTHeader.writeInt32BE(sfntVersion, 0); //SFNT Version
    SFNTHeader.writeUInt16BE(numTables, 4); //SFNT Number of Tables
    SFNTHeader.writeUInt16BE(searchRange, 6); //SFNT Search Range (Maximum power of 2 <= numTables) x 16.
    SFNTHeader.writeUInt16BE(entrySelector, 8); //SFNT Entry Selector (Log2(maximum power of 2 <= numTables).
    SFNTHeader.writeUInt16BE(rangeShift, 10); // SFNT Range Shift (NumTables x 16-searchRange.)
    return SFNTHeader;
}
/* inflate function returns uint8array/arrayBuffer, this helper converts it back to buffer */ function toBuffer(arrBuf) {
    var buf = Buffer.alloc(arrBuf.byteLength);
    var view = new Uint8Array(arrBuf);
    for(var i = 0; i < buf.length; ++i){
        buf[i] = view[i];
    }
    return buf;
}
//module.exports = sfnt2woff;
module.exports = {
    toWoff: sfnt2woff,
    toSfnt: woff2sfnt
};
}),
"[project]/node_modules/.pnpm/fontverter@2.0.0/node_modules/fontverter/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const wawoff2 = __turbopack_context__.r("[project]/node_modules/.pnpm/wawoff2@2.0.1/node_modules/wawoff2/index.js [app-route] (ecmascript)");
const woffTool = __turbopack_context__.r("[project]/node_modules/.pnpm/woff2sfnt-sfnt2woff@1.0.0/node_modules/woff2sfnt-sfnt2woff/index.js [app-route] (ecmascript)");
const supportedFormats = new Set([
    'sfnt',
    'woff',
    'woff2'
]);
exports.detectFormat = function(buffer) {
    const signature = buffer.toString('ascii', 0, 4);
    if (signature === 'wOFF') {
        return 'woff';
    } else if (signature === 'wOF2') {
        return 'woff2';
    } else if (signature === 'true' || signature === 'OTTO' || signature === '\x00\x01\x00\x00') {
        return 'sfnt';
    } else {
        throw new Error(`Unrecognized font signature: ${signature}`);
    }
};
exports.convert = async function(buffer, toFormat, fromFormat) {
    if (toFormat === 'truetype') {
        toFormat = 'sfnt';
    }
    if (fromFormat === 'truetype') {
        fromFormat = 'sfnt';
    }
    if (!supportedFormats.has(toFormat)) {
        throw new Error(`Unsupported target format: ${toFormat}`);
    }
    if (fromFormat) {
        if (!supportedFormats.has(fromFormat)) {
            throw new Error(`Unsupported source format: ${fromFormat}`);
        }
    } else {
        fromFormat = exports.detectFormat(buffer);
    }
    if (fromFormat === toFormat) {
        return buffer;
    }
    if (fromFormat === 'woff') {
        buffer = woffTool.toSfnt(buffer);
    } else if (fromFormat === 'woff2') {
        buffer = Buffer.from(await wawoff2.decompress(buffer));
    }
    if (toFormat === 'woff') {
        buffer = woffTool.toWoff(buffer);
    } else if (toFormat === 'woff2') {
        buffer = Buffer.from(await wawoff2.compress(buffer));
    }
    return buffer;
};
}),
"[project]/node_modules/.pnpm/harfbuzzjs@0.4.13/node_modules/harfbuzzjs/hb-subset.wasm [app-route] (wasm raw)", ((__turbopack_context__) => {

__turbopack_context__.v("server/chunks/87c17_harfbuzzjs_hb-subset_11d1fd06.wasm");}),
"[project]/node_modules/.pnpm/harfbuzzjs@0.4.13/node_modules/harfbuzzjs/hb-subset.wasm [app-route] (wasm module)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "__indirect_function_table",
    ()=>__indirect_function_table,
    "_emscripten_stack_restore",
    ()=>_emscripten_stack_restore,
    "_initialize",
    ()=>_initialize,
    "emscripten_stack_get_current",
    ()=>emscripten_stack_get_current,
    "free",
    ()=>free,
    "hb_blob_create",
    ()=>hb_blob_create,
    "hb_blob_destroy",
    ()=>hb_blob_destroy,
    "hb_blob_get_data",
    ()=>hb_blob_get_data,
    "hb_blob_get_length",
    ()=>hb_blob_get_length,
    "hb_face_create",
    ()=>hb_face_create,
    "hb_face_destroy",
    ()=>hb_face_destroy,
    "hb_face_get_empty",
    ()=>hb_face_get_empty,
    "hb_face_reference_blob",
    ()=>hb_face_reference_blob,
    "hb_set_add",
    ()=>hb_set_add,
    "hb_set_clear",
    ()=>hb_set_clear,
    "hb_set_create",
    ()=>hb_set_create,
    "hb_set_del",
    ()=>hb_set_del,
    "hb_set_destroy",
    ()=>hb_set_destroy,
    "hb_set_invert",
    ()=>hb_set_invert,
    "hb_set_union",
    ()=>hb_set_union,
    "hb_subset_input_create_or_fail",
    ()=>hb_subset_input_create_or_fail,
    "hb_subset_input_destroy",
    ()=>hb_subset_input_destroy,
    "hb_subset_input_get_flags",
    ()=>hb_subset_input_get_flags,
    "hb_subset_input_get_user_data",
    ()=>hb_subset_input_get_user_data,
    "hb_subset_input_glyph_set",
    ()=>hb_subset_input_glyph_set,
    "hb_subset_input_keep_everything",
    ()=>hb_subset_input_keep_everything,
    "hb_subset_input_pin_all_axes_to_default",
    ()=>hb_subset_input_pin_all_axes_to_default,
    "hb_subset_input_pin_axis_location",
    ()=>hb_subset_input_pin_axis_location,
    "hb_subset_input_pin_axis_to_default",
    ()=>hb_subset_input_pin_axis_to_default,
    "hb_subset_input_reference",
    ()=>hb_subset_input_reference,
    "hb_subset_input_set",
    ()=>hb_subset_input_set,
    "hb_subset_input_set_axis_range",
    ()=>hb_subset_input_set_axis_range,
    "hb_subset_input_set_flags",
    ()=>hb_subset_input_set_flags,
    "hb_subset_input_set_user_data",
    ()=>hb_subset_input_set_user_data,
    "hb_subset_input_unicode_set",
    ()=>hb_subset_input_unicode_set,
    "hb_subset_or_fail",
    ()=>hb_subset_or_fail,
    "hb_subset_preprocess",
    ()=>hb_subset_preprocess,
    "malloc",
    ()=>malloc,
    "memory",
    ()=>memory
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$harfbuzzjs$40$0$2e$4$2e$13$2f$node_modules$2f$harfbuzzjs$2f$hb$2d$subset$2e$wasm__$5b$app$2d$route$5d$__$28$wasm__raw$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/harfbuzzjs@0.4.13/node_modules/harfbuzzjs/hb-subset.wasm [app-route] (wasm raw)");
;
const { memory, free, __indirect_function_table, hb_blob_create, hb_blob_destroy, malloc, hb_blob_get_length, hb_blob_get_data, hb_face_get_empty, hb_face_create, hb_face_destroy, hb_face_reference_blob, hb_set_create, hb_set_destroy, hb_set_clear, hb_set_add, hb_set_del, hb_set_union, hb_set_invert, hb_subset_input_create_or_fail, hb_subset_input_destroy, hb_subset_input_reference, hb_subset_input_unicode_set, hb_subset_input_glyph_set, hb_subset_input_set, hb_subset_input_get_flags, hb_subset_input_set_flags, hb_subset_input_set_user_data, hb_subset_input_get_user_data, hb_subset_input_keep_everything, hb_subset_input_pin_all_axes_to_default, hb_subset_input_pin_axis_to_default, hb_subset_input_pin_axis_location, hb_subset_input_set_axis_range, hb_subset_preprocess, hb_subset_or_fail, _initialize, _emscripten_stack_restore, emscripten_stack_get_current } = await /*TURBOPACK member replacement*/ __turbopack_context__.w(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$harfbuzzjs$40$0$2e$4$2e$13$2f$node_modules$2f$harfbuzzjs$2f$hb$2d$subset$2e$wasm__$5b$app$2d$route$5d$__$28$wasm__raw$29$__["default"], ()=>wasm_5fb6bd81a4c8b3ba, {});
;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[project]/node_modules/.pnpm/subset-font@2.4.0/node_modules/subset-font/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* global WebAssembly */ const { readFile } = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)").promises;
const _ = __turbopack_context__.r("[project]/node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js [app-route] (ecmascript)");
const fontverter = __turbopack_context__.r("[project]/node_modules/.pnpm/fontverter@2.0.0/node_modules/fontverter/index.js [app-route] (ecmascript)");
const loadAndInitializeHarfbuzz = _.once(async ()=>{
    const { instance: { exports: harfbuzzJsWasm } } = await WebAssembly.instantiate(await readFile("[project]/node_modules/.pnpm/harfbuzzjs@0.4.13/node_modules/harfbuzzjs/hb-subset.wasm [app-route] (wasm module)"));
    const heapu8 = new Uint8Array(harfbuzzJsWasm.memory.buffer);
    return {
        harfbuzzJsWasm,
        heapu8
    };
});
function HB_TAG(str) {
    return str.split('').reduce(function(a, ch) {
        return (a << 8) + ch.charCodeAt(0);
    }, 0);
}
async function subsetFont(originalFont, text, { targetFormat = fontverter.detectFormat(originalFont), preserveNameIds, variationAxes, noLayoutClosure } = {}) {
    if (typeof text !== 'string') {
        throw new Error('The subset text must be given as a string');
    }
    const { harfbuzzJsWasm, heapu8 } = await loadAndInitializeHarfbuzz();
    originalFont = await fontverter.convert(originalFont, 'truetype');
    const input = harfbuzzJsWasm.hb_subset_input_create_or_fail();
    if (input === 0) {
        throw new Error('hb_subset_input_create_or_fail (harfbuzz) returned zero, indicating failure');
    }
    const fontBuffer = harfbuzzJsWasm.malloc(originalFont.byteLength);
    heapu8.set(new Uint8Array(originalFont), fontBuffer);
    // Create the face
    const blob = harfbuzzJsWasm.hb_blob_create(fontBuffer, originalFont.byteLength, 2, 0, 0);
    const face = harfbuzzJsWasm.hb_face_create(blob, 0);
    harfbuzzJsWasm.hb_blob_destroy(blob);
    // Do the equivalent of --font-features=*
    const layoutFeatures = harfbuzzJsWasm.hb_subset_input_set(input, 6 // HB_SUBSET_SETS_LAYOUT_FEATURE_TAG
    );
    harfbuzzJsWasm.hb_set_clear(layoutFeatures);
    harfbuzzJsWasm.hb_set_invert(layoutFeatures);
    if (preserveNameIds) {
        const inputNameIds = harfbuzzJsWasm.hb_subset_input_set(input, 4 // HB_SUBSET_SETS_NAME_ID
        );
        for (const nameId of preserveNameIds){
            harfbuzzJsWasm.hb_set_add(inputNameIds, nameId);
        }
    }
    if (noLayoutClosure) {
        harfbuzzJsWasm.hb_subset_input_set_flags(input, harfbuzzJsWasm.hb_subset_input_get_flags(input) | 0x00000200 // HB_SUBSET_FLAGS_NO_LAYOUT_CLOSURE
        );
    }
    // Add unicodes indices
    const inputUnicodes = harfbuzzJsWasm.hb_subset_input_unicode_set(input);
    for (const c of text){
        harfbuzzJsWasm.hb_set_add(inputUnicodes, c.codePointAt(0));
    }
    if (variationAxes) {
        for (const [axisName, value] of Object.entries(variationAxes)){
            if (typeof value === 'number') {
                // Simple case: Pin/instance the variation axis to a single value
                if (!harfbuzzJsWasm.hb_subset_input_pin_axis_location(input, face, HB_TAG(axisName), value)) {
                    harfbuzzJsWasm.hb_face_destroy(face);
                    harfbuzzJsWasm.free(fontBuffer);
                    throw new Error(`hb_subset_input_pin_axis_location (harfbuzz) returned zero when pinning ${axisName} to ${value}, indicating failure. Maybe the axis does not exist in the font?`);
                }
            } else if (value && typeof value === 'object') {
                // Complex case: Reduce the variation space of the axis
                if (typeof value.min === 'undefined' || typeof value.max === 'undefined') {
                    harfbuzzJsWasm.hb_face_destroy(face);
                    harfbuzzJsWasm.free(fontBuffer);
                    throw new Error(`${axisName}: You must provide both a min and a max value when setting the axis range`);
                }
                if (!harfbuzzJsWasm.hb_subset_input_set_axis_range(input, face, HB_TAG(axisName), value.min, value.max, // An explicit NaN makes harfbuzz use the existing default value, clamping to the new range if necessary
                value.default ?? NaN)) {
                    harfbuzzJsWasm.hb_face_destroy(face);
                    harfbuzzJsWasm.free(fontBuffer);
                    throw new Error(`hb_subset_input_set_axis_range (harfbuzz) returned zero when setting the range of ${axisName} to [${value.min}; ${value.max}] and a default value of ${value.default}, indicating failure. Maybe the axis does not exist in the font?`);
                }
            }
        }
    }
    let subset;
    try {
        subset = harfbuzzJsWasm.hb_subset_or_fail(face, input);
        if (subset === 0) {
            harfbuzzJsWasm.hb_face_destroy(face);
            harfbuzzJsWasm.free(fontBuffer);
            throw new Error('hb_subset_or_fail (harfbuzz) returned zero, indicating failure. Maybe the input file is corrupted?');
        }
    } finally{
        // Clean up
        harfbuzzJsWasm.hb_subset_input_destroy(input);
    }
    // Get result blob
    const result = harfbuzzJsWasm.hb_face_reference_blob(subset);
    const offset = harfbuzzJsWasm.hb_blob_get_data(result, 0);
    const subsetByteLength = harfbuzzJsWasm.hb_blob_get_length(result);
    if (subsetByteLength === 0) {
        harfbuzzJsWasm.hb_blob_destroy(result);
        harfbuzzJsWasm.hb_face_destroy(subset);
        harfbuzzJsWasm.hb_face_destroy(face);
        harfbuzzJsWasm.free(fontBuffer);
        throw new Error('Failed to create subset font, maybe the input file is corrupted?');
    }
    const subsetFont1 = Buffer.from(heapu8.subarray(offset, offset + subsetByteLength));
    // Clean up
    harfbuzzJsWasm.hb_blob_destroy(result);
    harfbuzzJsWasm.hb_face_destroy(subset);
    harfbuzzJsWasm.hb_face_destroy(face);
    harfbuzzJsWasm.free(fontBuffer);
    return await fontverter.convert(subsetFont1, targetFormat, 'truetype');
}
const limiter = __turbopack_context__.r("[project]/node_modules/.pnpm/p-limit@3.1.0/node_modules/p-limit/index.js [app-route] (ecmascript)")(1);
module.exports = (...args)=>limiter(()=>subsetFont(...args));
}),
];

//# sourceMappingURL=node_modules__pnpm_9f5cff28._.js.map